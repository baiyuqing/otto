{
  "tests/e2e.mjs": {
    "hash": "cf3ccafac67ba4704d4b549d75dc8a8b79d7a76daddc23ef5dfd81905caab572",
    "content": "import { test } from \"node:test\";\nimport assert from \"node:assert/strict\";\nimport { spawn } from \"node:child_process\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport os from \"node:os\";\n\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction getNodeBin() {\n  return process.execPath;\n}\n\nfunction readIfExists(filePath) {\n  try {\n    return fs.readFileSync(filePath, \"utf8\");\n  } catch {\n    return \"\";\n  }\n}\n\nfunction waitFor(predicate, timeoutMs = 5000, intervalMs = 200) {\n  const started = Date.now();\n  return new Promise((resolve, reject) => {\n    const tick = async () => {\n      if (await predicate()) {\n        resolve(true);\n        return;\n      }\n      if (Date.now() - started > timeoutMs) {\n        reject(new Error(\"Timed out waiting for condition\"));\n        return;\n      }\n      setTimeout(tick, intervalMs);\n    };\n    tick();\n  });\n}\n\ntest(\"end-to-end: watch -> log -> svg\", async () => {\n  const tmpRoot = fs.mkdtempSync(path.join(os.tmpdir(), \"agent-trace-\"));\n  const docsDir = path.join(tmpRoot, \"docs\");\n  fs.mkdirSync(docsDir, { recursive: true });\n\n  const conversationLog = path.join(tmpRoot, \"conversation.jsonl\");\n  fs.writeFileSync(\n    conversationLog,\n    JSON.stringify({\n      conversation_id: \"conv-1\",\n      message_id: \"msg-1\",\n      role: \"user\",\n      created_at: new Date().toISOString(),\n      content: \"Please track changes\",\n    }) + \"\\n\",\n    \"utf8\",\n  );\n\n  const traceLog = path.join(tmpRoot, \"docs\", \"agent-trace.md\");\n  const stateFile = path.join(tmpRoot, \".trace_state.json\");\n\n  const nodeBin = getNodeBin();\n  const watcher = spawn(\n    nodeBin,\n    [\n      \"--import\",\n      \"tsx\",\n      \"scripts/trace_watch.ts\",\n      \"--root\",\n      tmpRoot,\n      \"--log\",\n      traceLog,\n      \"--conversation-log\",\n      conversationLog,\n      \"--state\",\n      stateFile,\n      \"--debounce-ms\",\n      \"200\",\n    ],\n    {\n      stdio: [\"ignore\", \"pipe\", \"pipe\"],\n      env: {\n        ...process.env,\n        CHOKIDAR_USEPOLLING: \"1\",\n        CHOKIDAR_INTERVAL: \"100\",\n      },\n    },\n  );\n\n  let watcherExited = false;\n  let watcherStdErr = \"\";\n  let watcherStdOut = \"\";\n  watcher.stderr.on(\"data\", (chunk) => {\n    watcherStdErr += String(chunk);\n  });\n  watcher.stdout.on(\"data\", (chunk) => {\n    watcherStdOut += String(chunk);\n  });\n  watcher.on(\"exit\", () => {\n    watcherExited = true;\n  });\n\n  await sleep(500);\n\n  const sampleFile = path.join(tmpRoot, \"sample.py\");\n  fs.writeFileSync(sampleFile, \"def foo():\\n    return 1\\n\", \"utf8\");\n  await sleep(500);\n  fs.appendFileSync(sampleFile, \"\\n# change\\n\", \"utf8\");\n\n  await waitFor(() => {\n    if (watcherExited) {\n      throw new Error(`watcher exited early\\\\nstdout:\\\\n${watcherStdOut}\\\\nstderr:\\\\n${watcherStdErr}`);\n    }\n    return readIfExists(traceLog).includes(\"\\\"trace_entry\\\": true\");\n  }, 12000);\n\n  const svgPath = path.join(tmpRoot, \"docs\", \"agent-trace.svg\");\n  const svgRun = spawn(\n    nodeBin,\n    [\"--import\", \"tsx\", \"scripts/trace_svg.ts\", \"--log\", traceLog, \"--out\", svgPath],\n    {\n      stdio: \"ignore\",\n    },\n  );\n\n  await new Promise((resolve, reject) => {\n    svgRun.on(\"exit\", (code) => {\n      if (code === 0) resolve(true);\n      else reject(new Error(`trace_svg.ts exited with ${code}`));\n    });\n  });\n\n  const svg = readIfExists(svgPath);\n  assert.ok(svg.includes(\"<svg\"), \"SVG output missing <svg tag>\");\n  assert.ok(svg.includes(\"Conversation\"), \"SVG output missing Conversation label\");\n  assert.ok(svg.includes(\"Change\"), \"SVG output missing Change label\");\n\n  watcher.kill(\"SIGINT\");\n  await new Promise((resolve) => {\n    const timeout = setTimeout(() => {\n      watcher.kill(\"SIGKILL\");\n      resolve(true);\n    }, 1000);\n    watcher.on(\"exit\", () => {\n      clearTimeout(timeout);\n      resolve(true);\n    });\n  });\n});\n",
    "updated_at": "2026-02-05T13:42:39Z"
  }
}